# Web Application Security

## XSS

XSS(Cross-Site Scripting)，跨站脚本攻击，是用于客户端的攻击方式。理论上，所有可输入的地方没有对输入数据进行处理的话，都会存在 XSS 漏洞。XSS 漏洞只会对用户有害，和应用无关。一般使用注入 JavaScript 代码的方式

原理是当用户给服务器传输一些数据的时候，服务器可能会根据这些数据来拼接在网页上，但如果我传输的数据是 JavaScript 代码，那么在页面里时就会被执行，这时就可以让这个网页做你脚步里写的东西

XSS 分为两种，一种是不持久的，而另一种就是持久的

- **不持久的 XSS** 攻击一般需要用户点击黑客给定的特定链接，因为链接里给定了特定的参数发送到服务端，而服务端正好会获取这个参数值拼接在页面上，如果黑客给定的链接里有 `<script>` 代码，那么就会执行这里面的代码，就能达到黑客的目的，损害该用户的利益
- **持久的 XSS** 攻击则会把恶意代码存储到数据库中，例如我在某论坛中发布一篇文章，文章里有恶意代码，当其他人来看我这篇文章的时候，就会执行我放在里面的代码，从而窃取那些人的信息

> 那怎么防御 XSS 攻击

- 对于服务器来说，不要将任何不可信的数据插入到页面中，除非这些数据已经进行了编码
- 对于服务器来说，使用富文本的时候，使用 XSS 规则引擎进行编码过滤
- 对于用户来说，不要把敏感信息放在 cookie 里，许多 XSS 攻击和目标都是窃取用户 cookie

## CSRF

CSRF(Cross-Site Request Forgery)，跨站请求伪造。指的是攻击者盗用了你的身份，以你的名义发送发送恶意请求，例如邮件，消息，购买商品等等

CSRF 的原理如下

1. 用户 C 登录信任网站 A
2. **通过验证，在用户 C 处产生 A 的 cookie**
3. **用户在没有登出 A 的情况下，访问危险网站 B**
4. B 要求访问网站 A，发出一个请求
5. 用户 C 的浏览器就会访问 A，并带着 cookie
6. 网站 A 根据 cookie 拿到用户 C 权限，但是却做着 B 的请求

其中第二第三步就是必要的条件，如果不满足这两步的其中一步，就不会受到 CSRF 的攻击，但这两步并不容易确保不发生，为了方便，我们都喜欢自动登录，并且所谓的危险网站 B，还都是那些我们熟悉且经常访问的站点

一个简单的例子

一个银行网站 A，它以 GET 请求来完成银行转账的操作，如 `http://www.mybank.com/transfer.php?toBankId=11&money=1000`

而在危险网站 B 中，它里面有一段这样的 HTML 代码 `<img src="http://www.mybank.com/transfer.php?toBankId=11&money=1000" >`

我知道这个例子有太多的不合理，但是原理就是这样，你的账户就没有了 1000 块

**CSRF 之所以出现就是因为 Web 的身份验证机制，服务器虽然可以通过 cookie，session 来保证一个请求是来自于某个用户的，但是却无法保证该请求是不是用户批准发送的**

> 那怎么防御 CSRF 攻击

- **验证 HTTP Referer 字段**，这个字段记录了 HTTP 请求的来源地址，一般是用户在页面里触发的请求，都是这个页面本身所在的域。但如果是从危险网站发送过来的请求，HTTP Referer 就会指向危险网站的域。服务端可以在后台对该字段进行判断，如果非同域的请求应该拒绝
- **请求中加入 token**，如果黑客伪造的请求没有这个 token 或者 token 的类型和内容不对，就可以判断是否为 CSRF 攻击。我们可以把这个 token 放在 session 中。在请求时拿出来与参数中的和 token 对比