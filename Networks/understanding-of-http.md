# Understanding of HTTP

HTTP，超文本传送协议(HyperText Transfer Protocol)，是 TCP/IP 模型应用层中的其中一种协议

## HTTP 协议的特点

- **支持 C/S 模式**: 我们绝大多数的 Web App，都是使用这种模式
- **简单快速**: 客户向服务器请求服务时，只需传送请求方法和路径，所以简单，由于简单，所以通信速度很快
- **灵活**: HTTP 允许传输任意类型的数据对象
- **无连接**: 所以通信的双方直接使用了下层运输层的 TCP 连接，但在交换 HTTP 报文之前不再需要建立 HTTP 连接
- **无状态**: 这让服务器不需要知道哪个客户访问过它，这可以简化服务器的设计，使服务器更容易支持大量并发 HTTP 请求，因此也引入了 Cookie

## HTTP 请求

当我们发送请求的时候，客户端就会给服务发送一个请求报文，这个报文由三部分组成

- **请求行** 格式: 请求方法 请求URL HTTP版本
- **消息报头**
- **请求正文** 

### 请求方法

- **GET** 获取
- **POST** 新增
- **PUT** 修改
- **DELETE** 删除
- HEAD
- OPTION
- TRACE
- CONNECT

## HTTP 响应

在接收和解释请求消息后，服务器返回一个 HTTP 响应报文，这个报文也由三部分组成

- **状态行**: 格式: HTTP版本 状态码 状态码描述
- **消息报头**
- **响应正文**

### 状态码(常见)

- 1xx: 表示请求已接收，继续处理
- 200: 成功 OK
- 304: 没有修改
- 400: 错误的请求
- 404: 资源不存在
- 5xx: 服务器错误

## 消息报头

- Connection
    
    keep-alive 或 close。在 HTTP/1.1 之后，所有的连接都默认为持续连接，直到客户端或服务器端任一端主动提出关闭，在请求头或响应头 `Connection: close`
    
- Expires

    在响应报文中返回，单词是过期的意思，就是说明该资源什么时候到期，是一个绝对的格林威治时间。所以当 web 服务器的时间被修改后，就会导致缓存时间的不可靠
    
- Cache-Control

    HTTP/1.1 新增，目的为了增加 Expires 的可靠性。一般由服务器端返回，标记该资源可以在浏览器缓存中存活的相对时间，以秒为单位
    
   > **Expires 和 Cache-Control 一般用来识别静态资源是否命中强缓存，如果再次请求时，没有超过该资源在浏览器缓存里的时间，那么就浏览器就不会再向服务器端发送请求，而直接在浏览器缓存里获取第一次请求返回的响应报文和资源数据**

- Last-Modified、If-Modified-Since

    另一种的缓存机制是，服务器可以在返回资源的时候，返回一个 Last-Modified 的头部，存储的是当前时间。这个时间会在同一个资源请求的时候，当成 If-Modified-Since 的值传到服务器，用来判断该资源是否有修改过，如果没有修改过，则返回 304 Not Modified，然后浏览器就会在缓存中获取数据，不需要重新下载

- ETag、If-None-Match

    这一对也是实现上面功能的另一种方法，服务器在返回资源的时候，也会在响应报文里添加 ETag，它的值是 hash 码，当再次请求的时候，请求报文就会有一个 If-None-Match 的报头信息，值就是这个 ETag 的 hash 码，如果相同，则返回 304

- Set-Cookie、Cookie

    因为 HTTP 是无状态的，所以如果想要识别某一个请求，可以在第一次请求的时候，返回 Set-Cookie 响应报文头信息，让浏览器的 cookie 保存起来，这样当浏览器再次请求这个服务器的时候，请求头就会有 Cookie 这个头信息，值就是 Set-Cookie 给我们返回的值。服务器就可以识别这个请求的信息了

[Cookie 和 Web Storage 的区别](https://github.com/L-movingon/prepare-for-interview/blob/master/HTML/difference-between-webstorage-cookies-and-session.md)

## HTTP/1.0 vs HTTP/1.1

HTTP/1.0 的两大缺点

- **连接无法复用**: HTTP 本身是无连接的，所以每次请求都要开启一个 TCP 连接，当请求返回之后，TCP 连接断开，所以每一个请求都要经历三次握手和慢启动
- **请求占用**: 当连续发送多个请求时，第一个请求在没有收到回复之前，后续的请求只能排队，一旦一个请求没有及时返回，那么将影响到后面所有的请求

而 HTTP/1.1 则默认开启了持续连接，可以在协议头中来设置 Connection 来控制复用时间，而它工作的流水式方式可以让多个请求依次发出，但还是不能完全解决请求占用的问题，因为虽然可以多个请求依次发出，但在第一个请求没有返回的时候，第二个请求也不会被返回

## SPDY

HTTP/2.0 的前身，由 Google 提出，可以分为基础功能和高级功能两部分

- 基础功能
    - 多路复用: 多个请求共享一个 TCP 连接
    - 请求优先级: 可以为请求设置优先级，优先级高先响应
    - header 压缩: 对 header 的压缩率达到 80% 以上
- 高级功能
    - Server 推送: Server 主动给客户端推送资源
    - Server 暗示: 告诉客户端有新内容产生，让客户端主动发起请求
    
## HTTP/2.0

HTTP/2.0 的主要改动

- **新的二进制格式**: 把整个报文 header 和 body 分别封装
- **连接共享**: 一个连接可以多个请求且可以设置优先级避免阻塞
- **header 压缩**
- **Server Push**

## HTTP vs HTTPS

HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，所以容易直接从报文中截取信息。客户端和服务器端都无法验证对方的身份

HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密

主要的区别有

- HTTP 的 URL 以 `http://` 开头，而 HTTPS 的 URL 以 `https://` 开头
- HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
- 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 工作在传输层
- HTTP 无法加密，而HTTPS 对传输的数据进行加密
- HTTP无需证书，而HTTPS 需要认证证书(SSL数字证书)